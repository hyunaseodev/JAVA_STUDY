# Chapter 07. 객체지향 프로그래밍II

## 1. 상속(inheritance)

### 상속의 정의와 장점

- 상속이란, 기존이 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
- 자손 클래스들의 공통적인 부분은 조상클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리하면 되므로 각 클래스의 코드가 적어져서 관리가 쉬워진다.

```java
class Child extend Parent {
	//...
}
```

- 조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다.
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 따로 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다.

### 클래스간의 관계 - 포함관계

- 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

### 클래스간의 관계 결정하기

- 상속관계: '~은 ~이다.(is-a)'
- 포함관계: '~은 ~을 가지고 있다.(has-a)'

### Object클래스 - 모든 클래스의 조상

- 모든 상속계층도의 최상위에는 Object클래스가 위치한다.
- 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있다.

## 2. 오버라이딩(overriding)

### 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

### 오버라이딩의 조건

- 메서드의 내용만을 새로 작성
- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

### super

- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.

### super()

- 조상 클래스의 생성자를 호출하는데 사용된다.
- Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super(),를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.

## 4. 제어자(modifier)

### 제어자란?

- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
- 종류
    - 접근 제어자: public, protected, default, private
    - 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp
    

### static - 클래스의, 공통적인

- static이 사용될 수 있는 곳
    
    : 멤버변수, 메서드, 초기화 블럭
    
- static이 붙으면 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

### final - 마지막의, 변경될 수 없는

- final이 사용될 수 있는 곳
    
    : 클래스, 메서드, 멤버변수, 지역변수
    
- 변수에 사용되면 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

### abstract - 추상의, 미완성의

- abstract이 사용될 수 있는 곳
    
    : 클래스, 메서드
    
- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.
- 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.
- 추상 클래스는 미완성 설계도이므로 인스턴스를 생성할 수 없다.

### 접근 제어자(access modifier)

- 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
    - private - 같은 클래스 내에서만 접근 가능
    - default - 같은 패키지 내에서만 접근 가능
    - protected - 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능
    - public - 접근 제한 전혀 없음
- 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해(캡슐화)
    - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해
- 생성자에 접근 제어자를 사용하여 인스턴스의 생성을 제한할 수 있다.
생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다.
    
    생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
    

## 5. 다형성(polymorphism)

- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함.
- 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
    
    반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.
    

### 참조변수의 형변환

- 자손타입 → 조상타입(Up-casting) : 형변환 생략가능
- 자손타입 ← 조상타입(Down-casting) : 형변환 생략불가

### instanceof 연산자

- 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

### 참조변수와 인스턴스의 연결

- 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.

## 6. 추상클래스(abstract class)

### 추상클래스란?

- 미완성 메서드(추상메서드)를 포함하고 있는 클래스
- 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.

### 추상메서드

- 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것

```java
abstract 리턴타입 메서드이름();
```

- 추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.

## 7. 인터페이스(interface)

- 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있다.
- interface에도 클래스와 같이 접근제어자로 public 또는 default를 사용할 수 있다.

```java
interface 인터페이스이름 {
		public static final 타입 상수이름 = 값;
		public abstract 메서드이릅(매개변수목록);
}
```

- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
    
    모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
    
    단, static메서드와 디폴트 메서드는 예외(JDK 1.8부터)
    

### 인터페이스 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 다중상속이 가능하다.

```java
interface Movable {
		void move(int x, int y);
}

interface Attackable {
		void attack(Unit u);
}

interface Fightable extends Movable, Attackable { } 
```

### 인터페이스 구현

- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.

### 인터페이스를 이용한 다형성

- 인터페이스 타입의 참조변수로 이를 구현한 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환이 가능하다.

```java
Fightable f = (Fightable) new Fighter();
//또는
Fightable f = new Fighter();
```

- 인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것이다.
- 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것의 의미한다.

### 인터페이스 장점

- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.