# Chapter 06. 객체지향 프로그래밍 I

## 1. 객체지향언어

- 특징
    - 코드의 재사용성이 높다.
    - 코드의 관리가 용이다하.
    - 신뢰성이 높은 프로그래밍을 가능하게 한다.
        
        (제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
        
        코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.)
        

## 2. 클래스와 객체

### 클래스와 객체의 정의와 용도

- 클래스란 객체를 정의해 놓은 것이다. 객체를 생성하는데 사용된다.(객체지향이론의 관점)
    
    데이터와 함수의 결합/ 사용자정의 타입(프로그래밍적인 관점)
    
- 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.

### 인스턴스의 생성과 사용

- 클래스로부터 인스턴스를 생성하는 방법
    
    ```java
    클래스명 변수명;          //클래스의 객체를 참조하기 위한 참조변수 선언
    변수명 = new 클래스명();  //클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
    ```
    
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.

### 객체 배열

- 객체 배열은 참조변수들을 하나로 묶은 참조 변수 배열인 것이다.
- 객체 배열을 생성하는 것은, 객체를 다루기 위한 참조변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았다. 객체를 생성해서 객체 배열의 각 요소에 저장하는 것을 잊으면 안 된다.

```java
Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

- 같은 타입의 객체만 저장할 수 있다.

## 3. 변수와 메서드

### 선언위치에 따른 변수의 종류

- 클래스 영역: 클래스변수(cv), 인스턴스변수(iv)
    - 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.
    - 클래스변수는 인스턴스변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다.
    - 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지되며, public 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 '전역변수(global variable)'의 성격을 갖는다.
- 클래스 영역 이외의 영역: 지역변수(lv)

### 메서드 선언(method declaration/header)

- 메서드 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야한다. 메서드의 선언부를 변경하게 되면, 그 메서드가 호출되는 모든 곳도 같이 변경해야 하기 때문이다.
- 매개변수 선언시 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.

### 메서드의 호출

- 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.

### JVM의 메모리 구조

- 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
- 메서드 영역(method area)
    
    : 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수(cv)도 이 영역에 함께 생성된다.
    
- 힙(heap)
    
    : 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수(iv)들이 생성되는 공간이다.
    
- 호출스택
    
    : 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
    
    - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

### 기본형 매개변수와 참조형 매개변수

- 메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만(read only), 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물로 값을 변경하는 것도 가능하다.(read & write)
- 참조형 매개변수를 활용하면 반환값이 없어도 메서드의 실행결과를 얻어 올 수 있다.
    
    (배열도 객체와 같이 참조변수를 통해 데이터가 저장된 공간에 접근하므로)
    

### 참조형 반환타입

- 반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.

### 재귀호출(recursive call)

- 메서드의 내부에서 메서드 자신을 다시 호출하는 것을 '재귀호출'이라 하고, 재귀호출을 하는 메서드를 '재귀 메서드'라 한다.
- 재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 한다.
(대표적인 재귀호출의 예는 팩토리얼을 구하는 것)
- 무한 재귀호출이 일어나면 메서드가 종료되지 않으므로 스택에 계속 데이터가 쌓여만 간다. 어느 시점에 이르러서는 결국 스택의 저장한계를 넘게 되고, '스택오버플로우 에러(Stack Overflow Error)'가 발생한다.
    
    따라서 매개변수의 유효성검사가 중요하다.
    

### 클래스 메서드(static메서드)와 인스턴스 메서드

- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
- 메서드 중에서 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다.
    
    메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안 붙인 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.
    

### 클래스 멤버와 인스턴스 멤버간의 참조와 호출

- 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.
    
    인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만,
    
    클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.
    
- 인스턴스멤버간의 호출에는 아무런

## 4. 오버로딩(overloading)

- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩' 또는 '오버로딩'이라 한다.

### 오버로딩의 조건

- 메서드 이름이 같아야 한다.
- 매개변수의 **개수 또는 타입**이 달라야 한다.
- 반환 타입은 오버로딩을 구현하는데 아무련 영향을 못 줌
    
    (오버로딩된 메서드들은 매개변수에 의해서만 구별되므로)
    

### 오버로딩의 장점

- 메서드의 이름을 짓는데 고민을 덜 수 있다.

### 가변인자(varargs)와 오버로딩

- 기존에는 메서드의 매개변수 개수가 고정적이었으나, JDK1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 '가변인자(variable arguments)'라고 한다.
- **'타입... 변수명'**과 같은 형식으로 선언하며, PrintStream 클래스의 printf()가 대표적인 예이다.

```java
public PrintStream printf(String format, Object... args) { ... }
```

- 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면, 컴파일 에러가 발생한다.
- 가변인자는 내부적으로 배열을 이용한다. 그래서 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다. 가변인자가 편리하지만, 이런 비효율이 숨어있으므로 꼭 필요한 경우에만 가변인자를 사용한다.

## 5. 생성자(Constructor)

### 생성자란?

- 생성자는 인스턴ㅅ가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다
    
    (인스턴스 초기화 = 인스턴스 변수 초기화하는 것)
    
- 생성자 조건
    - 생성자의 이름은 클래스의 이름과 같아야 한다.
    - 생성자는 리턴 값이 없다.
- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
- 인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해줘야 한다.

### 기본 생성자(default constructor)

- 컴파일 할 때, 소스파일(*.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일 한다.
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

### 매개변수가 있는 생성자

- 인스턴스를 생성한 다음에 인스턴스변수의 값을 변경하는 것보다 매개변수를 갖는 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만든다.

### 생성자에서 다른 생성자 호출하기 - this(), this

- 같은 클래스의 생성자 간에 서로 호출이 가능하며 두 조건을 만족시켜야 한다.
    - 생성자의 이름으로 클래스이름 대신 this를 사용한다.
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
        
        (다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.
        
- this(), this(매개변수)
    
    : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
    
- this
    
    : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
    

## 6. 변수의 초기화

- 멤버변수(클래스변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만(초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화되므로),
지역변수의 초기화는 필수적이다.
- 멤버변수의 초기화 방법
    - 명시적 초기화(explicit initaliztion)
    - 생성자(constructor)
    - 초기화 블럭(initialization block)
        - 인스턴스 초기화 블럭: 인스턴스변수를 초기화 하는데 사용.
        - 클래스 초기화 블럭: 클래스변수를 초기화 하는데 사용.

### 명시적 초기화(explicit initaliztion)

- 변수를 선언과 동시에 초기화 하는 것
- 가장 기본적이면서도 간단한 초기화 방법이므로 여러 초기화 방법 중에서 가장 우선적으로 고려되어야 한다.

### 초기화 블럭(initialization block)

- 클래스 초기화 블럭: 클래스변수의 복잡한 초기화에 사용된다.
- 인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다.

```java
class InitBlock {
	static { } //클래스 초기화 블럭
	{ }        //인스턴스 초기화 블럭
	// ...
}
```

### 멤버변수의 초기화 시기와 순서

- 클래스변수의 초기화시점: 클래스가 처음 로딩될 때 단 한번 초기화 된다.
- 인스턴스변수의 초기화시점: 인스턴스가 생성될 때마다 각 인스턴스변로 초기화가 이루어진다.
- 클래스변수의 초기화순서: 기본값 → 명시적초기화 → 클래스 초기화 블럭
- 인스턴스변수의 초기화순서: 기본값 → 명시적초기화 → 인스턴스 초기화 블럭 → 생성자